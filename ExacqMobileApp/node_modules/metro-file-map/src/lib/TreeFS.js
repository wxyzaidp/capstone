"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.default = void 0;
var _constants = _interopRequireDefault(require("../constants"));
var fastPath = _interopRequireWildcard(require("../lib/fast_path"));
var _invariant = _interopRequireDefault(require("invariant"));
var _path = _interopRequireDefault(require("path"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
    return { default: obj };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *
 */

class TreeFS {
  #rootDir;
  #files;
  #rootNode = new Map();
  constructor({ rootDir, files }) {
    this.#rootDir = rootDir;
    this.#files = files;
    this.bulkAddOrModify(files);
  }
  getSerializableSnapshot() {
    return new Map(Array.from(this.#files.entries(), ([k, v]) => [k, [...v]]));
  }
  getModuleName(file) {
    const fileMetadata = this._getFileData(file);
    return (fileMetadata && fileMetadata[_constants.default.ID]) ?? null;
  }
  getSize(file) {
    const fileMetadata = this._getFileData(file);
    return (fileMetadata && fileMetadata[_constants.default.SIZE]) ?? null;
  }
  getDependencies(file) {
    const fileMetadata = this._getFileData(file);
    if (fileMetadata) {
      return fileMetadata[_constants.default.DEPENDENCIES]
        ? fileMetadata[_constants.default.DEPENDENCIES].split(
            _constants.default.DEPENDENCY_DELIM
          )
        : [];
    } else {
      return null;
    }
  }
  getSha1(file) {
    const fileMetadata = this._getFileData(file);
    return (fileMetadata && fileMetadata[_constants.default.SHA1]) ?? null;
  }
  exists(file) {
    const result = this._getFileData(file);
    return result != null;
  }
  getAllFiles() {
    return Array.from(this._regularFileIterator(), (normalPath) =>
      this._normalToAbsolutePath(normalPath)
    );
  }
  linkStats(file) {
    const fileMetadata = this._getFileData(file, {
      follow: false,
    });
    if (fileMetadata == null) {
      return null;
    }
    const fileType = fileMetadata[_constants.default.SYMLINK] === 0 ? "f" : "l";
    const modifiedTime = fileMetadata[_constants.default.MTIME];
    (0, _invariant.default)(
      typeof modifiedTime === "number",
      "File in TreeFS missing modified time"
    );
    return {
      fileType,
      modifiedTime,
    };
  }
  matchFiles(pattern) {
    const regexpPattern =
      pattern instanceof RegExp ? pattern : new RegExp(pattern);
    const files = [];
    for (const filePath of this._pathIterator()) {
      const absolutePath = this._normalToAbsolutePath(filePath);
      if (regexpPattern.test(absolutePath)) {
        files.push(absolutePath);
      }
    }
    return files;
  }

  /**
   * Given a search context, return a list of file paths matching the query.
   * The query matches against normalized paths which start with `./`,
   * for example: `a/b.js` -> `./a/b.js`
   */
  matchFilesWithContext(root, context) {
    const normalRoot = this._normalizePath(root);
    const contextRootResult = this._lookupByNormalPath(normalRoot);
    if (!contextRootResult) {
      return [];
    }
    const { normalPath: rootRealPath, node: contextRoot } = contextRootResult;
    if (!(contextRoot instanceof Map)) {
      return [];
    }
    const contextRootAbsolutePath =
      rootRealPath === ""
        ? this.#rootDir
        : _path.default.join(this.#rootDir, rootRealPath);
    const files = [];
    const prefix = "./";
    for (const relativePosixPath of this._pathIterator({
      pathSep: "/",
      recursive: context.recursive,
      rootNode: contextRoot,
      subtreeOnly: true,
    })) {
      if (
        context.filter.test(
          // NOTE(EvanBacon): Ensure files start with `./` for matching purposes
          // this ensures packages work across Metro and Webpack (ex: Storybook for React DOM / React Native).
          // `a/b.js` -> `./a/b.js`
          prefix + relativePosixPath
        )
      ) {
        const relativePath =
          _path.default.sep === "/"
            ? relativePosixPath
            : relativePosixPath.replaceAll("/", _path.default.sep);
        files.push(contextRootAbsolutePath + _path.default.sep + relativePath);
      }
    }
    return files;
  }
  getRealPath(filePath) {
    const normalPath = this._normalizePath(filePath);
    const metadata = this.#files.get(normalPath);
    if (metadata && metadata[_constants.default.SYMLINK] === 0) {
      return fastPath.resolve(this.#rootDir, normalPath);
    }
    const result = this._lookupByNormalPath(normalPath, {
      follow: true,
    });
    if (!result || result.node instanceof Map) {
      return null;
    }
    return fastPath.resolve(this.#rootDir, result.normalPath);
  }
  addOrModify(filePath, metadata) {
    const normalPath = this._normalizePath(filePath);
    this.bulkAddOrModify(new Map([[normalPath, metadata]]));
  }
  bulkAddOrModify(addedOrModifiedFiles) {
    for (const [normalPath, metadata] of addedOrModifiedFiles) {
      this.#files.set(normalPath, metadata);
      const directoryParts = normalPath.split(_path.default.sep);
      const basename = directoryParts.pop();
      const directoryNode = this._mkdirp(directoryParts);
      if (metadata[_constants.default.SYMLINK] !== 0) {
        const symlinkTarget = metadata[_constants.default.SYMLINK];
        (0, _invariant.default)(
          typeof symlinkTarget === "string",
          "expected symlink targets to be populated"
        );
        let rootRelativeSymlinkTarget;
        if (_path.default.isAbsolute(symlinkTarget)) {
          rootRelativeSymlinkTarget = fastPath.relative(
            this.#rootDir,
            symlinkTarget
          );
        } else {
          rootRelativeSymlinkTarget = _path.default.normalize(
            _path.default.join(_path.default.dirname(normalPath), symlinkTarget)
          );
        }
        directoryNode.set(basename, rootRelativeSymlinkTarget);
      } else {
        directoryNode.set(basename, metadata);
      }
    }
  }
  remove(filePath) {
    const normalPath = this._normalizePath(filePath);
    const fileMetadata = this.#files.get(normalPath);
    if (fileMetadata == null) {
      return null;
    }
    this.#files.delete(normalPath);
    const directoryParts = normalPath.split(_path.default.sep);
    const basename = directoryParts.pop();
    const directoryNode = this._mkdirp(directoryParts);
    directoryNode.delete(basename);
    return fileMetadata;
  }
  _lookupByNormalPath(
    relativePath,
    opts = {
      follow: true,
    },
    seen = new Set()
  ) {
    if (relativePath === "") {
      return {
        normalPath: "",
        node: this.#rootNode,
      };
    }
    seen.add(relativePath);
    const directoryParts = relativePath.split(_path.default.sep);
    const basename = directoryParts.pop();
    let node = this.#rootNode;
    for (const [idx, directoryPart] of directoryParts.entries()) {
      if (directoryPart === ".") {
        continue;
      }
      const nextNode = node.get(directoryPart);
      if (nextNode == null) {
        return null;
      }
      if (Array.isArray(nextNode)) {
        // Regular file in a directory path
        return null;
      } else if (typeof nextNode === "string") {
        if (seen.has(nextNode)) {
          // TODO: Warn `Symlink cycle detected: ${[...seen, node].join(' -> ')}`
          return null;
        }
        return this._lookupByNormalPath(
          _path.default.join(
            nextNode,
            ...directoryParts.slice(idx + 1),
            basename
          ),
          opts,
          seen
        );
      }
      node = nextNode;
    }
    const basenameNode = node.get(basename);
    if (typeof basenameNode === "string") {
      // basenameNode is a symlink target
      if (!opts.follow) {
        return {
          normalPath: relativePath,
          node: basenameNode,
        };
      }
      if (seen.has(basenameNode)) {
        // TODO: Warn `Symlink cycle detected: ${[...seen, target].join(' -> ')}`
        return null;
      }
      return this._lookupByNormalPath(basenameNode, opts, seen);
    }
    return basenameNode
      ? {
          normalPath: relativePath,
          node: basenameNode,
        }
      : null;
  }
  _normalizePath(relativeOrAbsolutePath) {
    return _path.default.isAbsolute(relativeOrAbsolutePath)
      ? fastPath.relative(this.#rootDir, relativeOrAbsolutePath)
      : _path.default.normalize(relativeOrAbsolutePath);
  }
  _normalToAbsolutePath(normalPath) {
    if (normalPath[0] === ".") {
      return _path.default.normalize(
        this.#rootDir + _path.default.sep + normalPath
      );
    } else {
      return this.#rootDir + _path.default.sep + normalPath;
    }
  }
  *_regularFileIterator() {
    for (const [normalPath, metadata] of this.#files) {
      if (metadata[_constants.default.SYMLINK] !== 0) {
        continue;
      }
      yield normalPath;
    }
  }
  *_pathIterator({
    pathSep = _path.default.sep,
    recursive = true,
    rootNode,
    subtreeOnly = false,
  } = {}) {
    for (const [name, node] of rootNode ?? this.#rootNode) {
      if (subtreeOnly && name === "..") {
        continue;
      }
      if (Array.isArray(node)) {
        yield name;
      } else if (typeof node === "string") {
        const resolved = this._lookupByNormalPath(node);
        if (resolved == null) {
          continue;
        }
        const target = resolved.node;
        if (target instanceof Map) {
          if (!recursive) {
            continue;
          }
          // symlink points to a directory - iterate over its contents
          for (const file of this._pathIterator({
            pathSep,
            recursive,
            rootNode: target,
            subtreeOnly,
          })) {
            yield name + pathSep + file;
          }
        } else {
          // symlink points to a file - report it
          yield name;
        }
      } else if (recursive) {
        for (const file of this._pathIterator({
          pathSep,
          recursive,
          rootNode: node,
          subtreeOnly,
        })) {
          yield name + pathSep + file;
        }
      }
    }
  }
  _getFileData(
    filePath,
    opts = {
      follow: true,
    }
  ) {
    const normalPath = this._normalizePath(filePath);
    const metadata = this.#files.get(normalPath);
    if (
      metadata &&
      (!opts.follow || metadata[_constants.default.SYMLINK] === 0)
    ) {
      return metadata;
    }
    const result = this._lookupByNormalPath(normalPath, opts);
    if (!result || result.node instanceof Map) {
      return null;
    }
    return this.#files.get(result.normalPath);
  }
  _mkdirp(directoryParts) {
    let node = this.#rootNode;
    for (const directoryPart of directoryParts) {
      if (directoryPart === ".") {
        continue;
      }
      let nextNode = node.get(directoryPart);
      if (nextNode == null) {
        nextNode = new Map();
        node.set(directoryPart, nextNode);
      }
      (0, _invariant.default)(
        nextNode instanceof Map,
        "%s in %s is a file, directory expected",
        directoryPart,
        directoryParts
      );
      node = nextNode;
    }
    return node;
  }
}
exports.default = TreeFS;
